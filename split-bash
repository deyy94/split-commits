#!/bin/bash
set -e

BASE_BRANCH="main"
SOURCE_BRANCH="Ejemplo1"
LIMIT=2000

# --- Validaciones ---
git rev-parse --is-inside-work-tree &>/dev/null || {
  echo "‚ùå No est√°s en un repo Git."; exit 1; }
git rev-parse --verify "$SOURCE_BRANCH" &>/dev/null || {
  echo "‚ùå La rama '$SOURCE_BRANCH' no existe."; exit 1; }

# --- Prepara la lista de commits (sin merges) ---
BASE_COMMIT=$(git merge-base "$BASE_BRANCH" "$SOURCE_BRANCH")
COMMITS=( $(git rev-list --reverse --no-merges "$BASE_COMMIT".."$SOURCE_BRANCH") )
TOTAL_COMMITS=${#COMMITS[@]}
echo "üîç $TOTAL_COMMITS commits desde $BASE_COMMIT hasta $SOURCE_BRANCH"

# --- Itera sobre los commits por √≠ndice ---
idx=0
parte=1

while (( idx < TOTAL_COMMITS )); do
  BR="${SOURCE_BRANCH}-parte-${parte}"
  echo
  echo "üöÄ Creando rama '$BR' (l√≠neas max $LINE_LIMIT)..."
  git branch "$BR" "$BASE_COMMIT"
  git checkout "$BR"

  sum=0
  # Aplicar commits hasta llegar al l√≠mite
  while (( idx < TOTAL_COMMITS )); do
    C=${COMMITS[idx]}
    # contar l√≠neas del commit
    lines=$(git show --numstat --format="" "$C" \
      | awk '{ add+=$1; del+=$2 } END{print add+del}')
    lines=${lines:-0}

    # si al aplicar este commit superamos el l√≠mite, salimos del bucle
    if (( sum + lines > LINE_LIMIT )); then
      break
    fi

    # cherry-pick (omitir si hay conflicto)
    echo "   üì¶ aplicando $C ($lines l√≠neas)..."
    if git cherry-pick "$C" &>/dev/null; then
      sum=$((sum + lines))
      idx=$((idx + 1))
    else
      echo "   ‚ö†Ô∏è  conflicto en $C, omitiendo."
      git cherry-pick --abort &>/dev/null
      idx=$((idx + 1))
    fi
  done

  echo "   ‚úÖ Rango aplicado: $sum l√≠neas en $BR"
  parte=$((parte + 1))
done

echo
echo "üéâ ¬°Listo! Se crearon $((parte-1)) ramas desde '$SOURCE_BRANCH'."
